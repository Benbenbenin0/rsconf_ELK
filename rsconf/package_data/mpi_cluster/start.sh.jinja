#!/bin/bash
set -euo pipefail

# Easier to have these defined here when prototyping
start_ssh_port='{{ mpi_cluster.ssh_port }}'

start_tls_d='{{ mpi_cluster.docker_tls_d }}'

start_guest_d='{{ mpi_cluster.guest_d }}'

start_conf_guest_d=$start_guest_d/.rsmpi

start_image='{{ mpi_cluster.docker_image }}'

start_cname=rsmpiexec

start_workers=(
{% for w in mpi_cluster.workers %}
    '{{ w }}'
{% endfor %}
)

start_jupyterhub_root_d='{{ mpi_cluster.jupyterhub_root_d }}'

start_docker() {
    local host=$1
    shift
    local host_d=$1
    shift
    local tls_d=$start_tls_d/$host
    local docker=(
        docker
        --host=tcp://"$host":2376
        --tlsverify
        # POSIT: component.mpi_cluster uses same names
        --tlscacert="$tls_d"/cacert.pem
        --tlscert="$tls_d"/cert.pem
        --tlskey="$tls_d"/key.pem
    )
    "${docker[@]}" rm -f "$start_cname" || true
    # Always make sure image is up to date; cat avoids ansi codes
    "${docker[@]}" pull "$start_image" | cat
    local docker_run=(
        "${docker[@]}"
        run
        -d
        --log-driver=json-file
        --log-opt=max-size=1m
        --name="$start_cname"
        --network=host
        --rm
        --ulimit=core=0
        --ulimit=nofile=1024
        --user='{{ mpi_cluster.run_u }}'
        -v "$host_d:$start_guest_d"
        "$start_image"
    )
    "${docker_run[@]}" "$@"
}

start_err() {
    echo "$@" 1>2&
    return 1
}

start_main() {
    local user=${1:-}
    if [[ ! $user ]]; then
        echo 'usage: bash start.sh <github-user>' 1>&2
        exit 1
    fi
    local run_u=$(stat -c %U "$start_jupyterhub_root_d")
    if [[ $USER != $run_u ]]; then
        echo "must be run as '$run_u'" 1>&2
        exit 1
    fi
    local worker
    local worker_d
    local worker_guest_d
    local prev_d=$PWD
    local ip
    local host_pub slots
    local -i total_slots=0
    local host_d=$start_jupyterhub_root_d/$user
    local conf_d=$host_d/.rsmpi
    local x y
    # user part must exist
    rm -rf "$conf_d"
    mkdir -p "$conf_d"
    local net=
    local ip_slots=
    for worker in "${start_workers[@]}"; do
        worker_d=$conf_d/$worker
        worker_guest_d=$start_conf_guest_d/$worker
        mkdir -p "$worker_d"
        cd "$worker_d"
# generate secrets permanently per user/worker
        ssh-keygen -t ed25519 -f ssh_host_ed25519_key -q -N '' -C "$worker"
        ssh-keygen -t ed25519 -f id_ed25519 -q -N '' -C "$worker"
        worker_pub=$(cat ssh_host_ed25519_key.pub)
        cat > sshd_config <<EOF
AuthorizedKeysFile $worker_guest_d/id_ed25519.pub
HostKey $worker_guest_d/ssh_host_ed25519_key
ListenAddress $worker:$start_ssh_port
PasswordAuthentication no
PermitTunnel no
PermitUserEnvironment no
PrintLastLog no
PrintMotd no
Protocol 2
UseDNS no
EOF
        cd "$prev_d"
        ip=$(dig +short "$worker")
        cat >> "$conf_d"/ssh_config <<EOF
Host $ip
    Port $start_ssh_port
    IdentityFile $worker_guest_d/id_ed25519
EOF
        cat >> "$conf_d"/known_hosts <<EOF
[$ip]:$start_ssh_port $worker_pub
EOF
        chmod -R go-rwx "$conf_d"
# /srv/jupyter/<user>/whatever is part of the watch
        start_docker "$worker" "$host_d" /usr/sbin/sshd -D -f "$worker_guest_d/sshd_config"
        sleep 2
        slots=$(
            ssh -F "$conf_d"/ssh_config \
            -o IdentityFile="$worker_d"/id_ed25519 \
            -o UserKnownHostsFile="$conf_d"/known_hosts \
            "$ip" nproc
        )
        [[ $slots =~ ^[0-9]+$ ]]
        # ASSUME: hyperthreading so divide by two
        slots=$(( $slots / 2 ))
        total_slots+=$slots
        ip_slots+="'$ip slots=$slots'"$'\n'
        net=$(start_net "$ip" "$net")
    done
    local all_hosts=$(seq --separator=, ${#start_workers[0]}}
    (cat <<EOF1; cat <<EOF2) | install -m 550 /dev/stdin "$host_d"/bin/rsmpi
#!/bin/bash
set -euo pipefail

        for f in $(compgen -A function build_) $(compgen -A function install_); do
            declare -f "$f"
        done
        for f in $(compgen -A variable build_) $(compgen -A variable install_) $build_passenv; do
            declare -p "$f"
        done

_rsmpi_slots=(
$ip_slots
)

_rsmpi_hosts='$all_hosts'

_rsmpi_net='$net'

rsmpi_main "$@"
EOF2
}

start_net() {
    local ip=$1
    local net=$2
    local re=' dev ([^ ]+)'
    if [[ ! $(ip route get "$ip") =~ $re ]]; then
        start_err "no route to IP address: $ip"
    fi
    local dev=${BASH_REMATCH[1]}
    if [[ $dev == lo ]]; then
        if [[ ! $(ip route | fgrep "src $ip") =~ $re ]]; then
            start_err "no route to (non-local) IP address: $ip"
        fi
        dev=${BASH_REMATCH[1]}
    fi
    local re=' inet ([^ ]+)'
    if [[ ! $(ip addr show "$dev") =~ $re ]]; then
        start_err "cannot find device: $dev"
    fi
    local src=${BASH_REMATCH[1]}
    local NETWORK PREFIX
    eval $(ipcalc --prefix --network "$src")
    local new=$NETWORK/$PREFIX
    if [[ $net && $net != $new ]]; then
        start_err "ip $ip does not route to $net"
    fi
    echo "$new"
}

rsmpi_hosts_write() {
    local IFS=,
    echo "$ip =$slots" >> "$conf_d"/mpi_hosts
}

rsmpi_main() {
    local op=${1:-help}
    shift
    case "$op" in
        exec|help|status)
            "rsmpi_op_$op" "$@"
            ;;
        *)
            rsmpi_op_help
            ;;
    esac
}

rsmpi_op_exec() {
    local n=${1:-}
    shift
    local h=$_rsmpi_hosts
    if [[ ${1:-} =~ ^[0-9] ]]; then
        shift
    fi
    if (( $# < 2 )); then
        rsmpi_op_help
    fi
    if [[ ! -d ~/.ssh ]]; then
        install -d -m 700 ~/.ssh
    fi
    install -m 600 '$start_conf_guest_d/ssh_config' ~/.ssh/config
    install -m 600 '$start_conf_guest_d/known_hosts' ~/.ssh/known_hosts
    local f=/tmp/rsmpihosts$$
    rsmpi_hosts_write | install -m 600 /dev/stdin "$f"
    exec mpiexec --mca oop_tcp_if_include '$_rsmpi_net' --mca btl_tcp_if_include '$net' --hostfile "$f" "$@"
}

rsmpi_op_help() {
    cat <<EOF
usage: rsmpi exec|status|help ...

commands:
exec <processes> [<hosts>] your-mpi-program args...
    processes is the number of cores, which can be from 1 to $total_slots.
    hosts are identified by a list of numbers, which can be 1 up to $.
    Leave <hosts> out to give mpi all hosts.
EOF
}

start_main "$@"
